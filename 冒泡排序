冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。 “冒泡排序”的原理是：每一趟只能确定将一个数归位。即第一趟只能确定将末位上的
数（即第5 位）归位，第二趟只能将倒数第2 位上的数（即第4 位）归位，第三趟只能将倒数第3 位上的数（即第3 位）归位，而现在前面还有两个位置上的数没有归位，因此我们仍
然需要进行“第四趟”。 “第四趟”只需要比较第1 位和第2 位的大小。因为后面三个位置上的数归位了，现在第1 位是99，第2 位是76，无需交换。这5 个数的顺序不变仍然是99 76 35 18 12。到此排
序完美结束了，5 个数已经有4 个数归位，那最后一个数也只能放在第1 位了。
最后我们总结一下：如果有n 个数进行排序，只需将n1 个数归位，也就是说要进行 n-1 趟操作。而“每一趟”都需要从第1 位开始进行相邻两个数的比较，将较小的一个数放在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，直到最后一
个尚未归位的数，已经归位的数则无需再进行比较（已经归位的数你还比较个啥，浪费表情）。
冒泡排序的核心部分是双重嵌套循环。不难看出冒泡排序的时间复杂度是O(N 2)。这是一个非常高的时间复杂度
#include "stdio.h"
int main()
{
int max;
for(i=0;i<5;i++)
  scanf("%d",&a[i]); 
for(i=0;i<5;i++)
 {
  for(j=0;j<4-i;j++)
   if(a[j]<a[j+1])
     swap(a[j],a[j+1]);
 }
 }
